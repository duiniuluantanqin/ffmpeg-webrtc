/*
 * WebRTC muxer
 * Copyright (c) 2023 The FFmpeg Project
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include "libavutil/dict.h"
#include "libavutil/avassert.h"
#include "libavutil/mathematics.h"
#include "libavcodec/codec_desc.h"
#include "libavcodec/mpeg4audio.h"
#include "avformat.h"
#include "internal.h"
#include "mux.h"
#include "libavutil/opt.h"
#include "libavcodec/avcodec.h"
#include "libavutil/avstring.h"
#include "url.h"
#include "libavutil/random_seed.h"

typedef struct RTCContext {
    AVClass *av_class;

    /* Input audio and video codec parameters */
    AVCodecParameters *audio_par;
    AVCodecParameters *video_par;

    /* The ICE username and pwd fragment generated by the muxer. */
    char ice_ufrag_local[9];
    char ice_pwd_local[33];
    /* The SSRC of the audio and video stream, generated by the muxer. */
    uint32_t audio_ssrc;
    uint32_t video_ssrc;
    /* The PT(Payload Type) of stream, generated by the muxer. */
    uint8_t audio_payload_type;
    uint8_t video_payload_type;
    /**
     * The SDP offer generated by the muxer according to the codec parameters,
     * DTLS and ICE information.
     * */
    char *sdp_offer;

    /* The ICE username and pwd from remote server. */
    char *ice_ufrag_remote;
    char *ice_pwd_remote;
    /* The ICE candidate protocol, priority, host and port. */
    char *ice_protocol;
    int ice_priority;
    char *ice_host;
    int ice_port;
    /* The SDP answer received from the WebRTC server. */
    char *sdp_answer;

    /* The HTTP URL context is the transport layer for the WHIP protocol. */
    URLContext *whip_uc;
} RTCContext;

/**
 * Only support video(h264) and audio(opus) for now. Note that only baseline
 * and constrained baseline of h264 are supported.
 *
 * @return 0 if OK, AVERROR_xxx on error
 */
static int check_codec(AVFormatContext *s)
{
    int i;
    RTCContext *rtc = s->priv_data;

    for (i = 0; i < s->nb_streams; i++) {
        AVCodecParameters *par = s->streams[i]->codecpar;
        const AVCodecDescriptor *desc = avcodec_descriptor_get(par->codec_id);
        switch (par->codec_type) {
        case AVMEDIA_TYPE_VIDEO:
            if (rtc->video_par) {
                av_log(s, AV_LOG_ERROR, "Only one video stream is supported by RTC\n");
                return AVERROR(EINVAL);
            }
            rtc->video_par = par;

            if (par->codec_id != AV_CODEC_ID_H264) {
                av_log(s, AV_LOG_ERROR, "Unsupported video codec %s by RTC, choose h264\n",
                       desc ? desc->name : "unknown");
                return AVERROR(EINVAL);
            }
            if ((par->profile & ~FF_PROFILE_H264_CONSTRAINED) != FF_PROFILE_H264_BASELINE) {
                av_log(s, AV_LOG_ERROR, "Profile %d of stream %d is not baseline, currently unsupported by RTC\n",
                       par->profile, i);
                return AVERROR(EINVAL);
            }
            break;
        case AVMEDIA_TYPE_AUDIO:
            if (rtc->audio_par) {
                av_log(s, AV_LOG_ERROR, "Only one audio stream is supported by RTC\n");
                return AVERROR(EINVAL);
            }
            rtc->audio_par = par;

            if (par->codec_id != AV_CODEC_ID_OPUS) {
                av_log(s, AV_LOG_ERROR, "Unsupported audio codec %s by RTC, choose opus\n",
                    desc ? desc->name : "unknown");
                return AVERROR(EINVAL);
            }

            if (par->ch_layout.nb_channels != 2) {
                av_log(s, AV_LOG_ERROR, "Unsupported audio channels %d by RTC, choose stereo\n",
                    par->ch_layout.nb_channels);
                return AVERROR(EINVAL);
            }

            if (par->sample_rate != 48000) {
                av_log(s, AV_LOG_ERROR, "Unsupported audio sample rate %d by RTC, choose 48000\n", par->sample_rate);
                return AVERROR(EINVAL);
            }
            break;
        default:
            av_log(s, AV_LOG_ERROR, "Codec type '%s' for stream %d is not supported by RTC\n",
                   av_get_media_type_string(par->codec_type), i);
            return AVERROR(EINVAL);
        }
    }

    return 0;
}

/**
 * Generate SDP offer according to the codec parameters, DTLS and ICE information.
 * The below is an example of SDP offer:
 *
 *       v=0
 *       o=FFmpeg 4489045141692799359 2 IN IP4 127.0.0.1
 *       s=FFmpegPublishSession
 *       t=0 0
 *       a=group:BUNDLE 0 1
 *       a=extmap-allow-mixed
 *       a=msid-semantic: WMS
 *
 *       m=audio 9 UDP/TLS/RTP/SAVPF 111
 *       c=IN IP4 0.0.0.0
 *       a=ice-ufrag:a174B
 *       a=ice-pwd:wY8rJ3gNLxL3eWZs6UPOxy
 *       a=fingerprint:sha-256 EE:FE:A2:E5:6A:21:78:60:71:2C:21:DC:1A:2C:98:12:0C:E8:AD:68:07:61:1B:0E:FC:46:97:1E:BC:97:4A:54
 *       a=setup:actpass
 *       a=mid:0
 *       a=sendonly
 *       a=msid:FFmpeg audio
 *       a=rtcp-mux
 *       a=rtpmap:111 opus/48000/2
 *       a=ssrc:4267647086 cname:FFmpeg
 *       a=ssrc:4267647086 msid:FFmpeg audio
 *
 *       m=video 9 UDP/TLS/RTP/SAVPF 106
 *       c=IN IP4 0.0.0.0
 *       a=ice-ufrag:a174B
 *       a=ice-pwd:wY8rJ3gNLxL3eWZs6UPOxy
 *       a=fingerprint:sha-256 EE:FE:A2:E5:6A:21:78:60:71:2C:21:DC:1A:2C:98:12:0C:E8:AD:68:07:61:1B:0E:FC:46:97:1E:BC:97:4A:54
 *       a=setup:actpass
 *       a=mid:1
 *       a=sendonly
 *       a=msid:FFmpeg video
 *       a=rtcp-mux
 *       a=rtcp-rsize
 *       a=rtpmap:106 H264/90000
 *       a=fmtp:106 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f
 *       a=ssrc:107169110 cname:FFmpeg
 *       a=ssrc:107169110 msid:FFmpeg video
 *
 * Note that we don't use av_sdp_create to generate SDP offer because it doesn't
 * support DTLS and ICE information.
 *
 * @return 0 if OK, AVERROR_xxx on error
 */
static int generate_sdp_offer(AVFormatContext *s)
{
    int profile_iop;
    RTCContext *rtc = s->priv_data;

    if (rtc->sdp_offer) {
        av_log(s, AV_LOG_ERROR, "SDP offer is already set\n");
        return AVERROR(EINVAL);
    }

    snprintf(rtc->ice_ufrag_local, sizeof(rtc->ice_ufrag_local), "%08x",
             av_get_random_seed());
    snprintf(rtc->ice_pwd_local, sizeof(rtc->ice_pwd_local), "%08x%08x%08x%08x",
             av_get_random_seed(), av_get_random_seed(), av_get_random_seed(),
             av_get_random_seed());

    rtc->audio_ssrc = av_get_random_seed();
    rtc->video_ssrc = av_get_random_seed();

    rtc->audio_payload_type = 111;
    rtc->video_payload_type = 106;

    profile_iop = rtc->video_par->profile & FF_PROFILE_H264_CONSTRAINED ? 0xe0 : 0x00;
    rtc->sdp_offer = av_asprintf(
        "v=0\r\n"
        "o=FFmpeg 4489045141692799359 2 IN IP4 127.0.0.1\r\n"
        "s=FFmpegPublishSession\r\n"
        "t=0 0\r\n"
        "a=group:BUNDLE 0 1\r\n"
        "a=extmap-allow-mixed\r\n"
        "a=msid-semantic: WMS\r\n"
        ""
        "m=audio 9 UDP/TLS/RTP/SAVPF %u\r\n"
        "c=IN IP4 0.0.0.0\r\n"
        "a=ice-ufrag:%s\r\n"
        "a=ice-pwd:%s\r\n"
        "a=fingerprint:sha-256 EE:FE:A2:E5:6A:21:78:60:71:2C:21:DC:1A:2C:98:12:0C:E8:AD:68:07:61:1B:0E:FC:46:97:1E:BC:97:4A:54\r\n"
        "a=setup:active\r\n"
        "a=mid:0\r\n"
        "a=sendonly\r\n"
        "a=msid:FFmpeg audio\r\n"
        "a=rtcp-mux\r\n"
        "a=rtpmap:%u opus/%d/%d\r\n"
        "a=ssrc:%u cname:FFmpeg\r\n"
        "a=ssrc:%u msid:FFmpeg audio\r\n"
        ""
        "m=video 9 UDP/TLS/RTP/SAVPF %u\r\n"
        "c=IN IP4 0.0.0.0\r\n"
        "a=ice-ufrag:%s\r\n"
        "a=ice-pwd:%s\r\n"
        "a=fingerprint:sha-256 EE:FE:A2:E5:6A:21:78:60:71:2C:21:DC:1A:2C:98:12:0C:E8:AD:68:07:61:1B:0E:FC:46:97:1E:BC:97:4A:54\r\n"
        "a=setup:active\r\n"
        "a=mid:1\r\n"
        "a=sendonly\r\n"
        "a=msid:FFmpeg video\r\n"
        "a=rtcp-mux\r\n"
        "a=rtcp-rsize\r\n"
        "a=rtpmap:%u H264/90000\r\n"
        "a=fmtp:%u level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=%02x%02x%02x\r\n"
        "a=ssrc:%u cname:FFmpeg\r\n"
        "a=ssrc:%u msid:FFmpeg video\r\n",
        rtc->audio_payload_type,
        rtc->ice_ufrag_local,
        rtc->ice_pwd_local,
        rtc->audio_payload_type,
        rtc->audio_par->sample_rate,
        rtc->audio_par->ch_layout.nb_channels,
        rtc->audio_ssrc,
        rtc->audio_ssrc,
        rtc->video_payload_type,
        rtc->ice_ufrag_local,
        rtc->ice_pwd_local,
        rtc->video_payload_type,
        rtc->video_payload_type,
        rtc->video_par->profile & (~FF_PROFILE_H264_CONSTRAINED),
        profile_iop,
        rtc->video_par->level,
        rtc->video_ssrc,
        rtc->video_ssrc
    );
    av_log(s, AV_LOG_VERBOSE, "Generated offer: %s", rtc->sdp_offer);

    return 0;
}

/**
 * Exchange SDP offer with WebRTC peer to get the answer.
 * The below is an example of SDP answer:
 *
 *       v=0
 *       o=SRS/6.0.42(Bee) 107408542208384 2 IN IP4 0.0.0.0
 *       s=SRSPublishSession
 *       t=0 0
 *       a=ice-lite
 *       a=group:BUNDLE 0 1
 *       a=msid-semantic: WMS live/show
 *
 *       m=audio 9 UDP/TLS/RTP/SAVPF 111
 *       c=IN IP4 0.0.0.0
 *       a=ice-ufrag:ex9061f9
 *       a=ice-pwd:bi8k19m9n836187b00d1gm3946234w85
 *       a=fingerprint:sha-256 68:DD:7A:95:27:BD:0A:99:F4:7A:83:21:2F:50:15:2A:1D:1F:8A:D8:96:24:42:2D:A1:83:99:BF:F1:E2:11:A2
 *       a=setup:passive
 *       a=mid:0
 *       a=recvonly
 *       a=rtcp-mux
 *       a=rtcp-rsize
 *       a=rtpmap:111 opus/48000/2
 *       a=candidate:0 1 udp 2130706431 172.20.10.7 8000 typ host generation 0
 *
 *       m=video 9 UDP/TLS/RTP/SAVPF 106
 *       c=IN IP4 0.0.0.0
 *       a=ice-ufrag:ex9061f9
 *       a=ice-pwd:bi8k19m9n836187b00d1gm3946234w85
 *       a=fingerprint:sha-256 68:DD:7A:95:27:BD:0A:99:F4:7A:83:21:2F:50:15:2A:1D:1F:8A:D8:96:24:42:2D:A1:83:99:BF:F1:E2:11:A2
 *       a=setup:passive
 *       a=mid:1
 *       a=recvonly
 *       a=rtcp-mux
 *       a=rtcp-rsize
 *       a=rtpmap:106 H264/90000
 *       a=fmtp:106 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01e
 *       a=candidate:0 1 udp 2130706431 172.20.10.7 8000 typ host generation 0
 *
 * @return 0 if OK, AVERROR_xxx on error
 */
static int exchange_sdp(AVFormatContext *s)
{
    int ret;
    char headers[MAX_URL_SIZE], buf[MAX_URL_SIZE];
    char *p;
    RTCContext *rtc = s->priv_data;

    ret = ffurl_alloc(&rtc->whip_uc, s->url, AVIO_FLAG_READ_WRITE, &s->interrupt_callback);
    if (ret < 0) {
        av_log(s, AV_LOG_ERROR, "Failed to alloc HTTP context: %s", s->url);
        return ret;
    }

    snprintf(headers, sizeof(headers),
             "Cache-Control: no-cache\r\n"
             "Content-Type: application/sdp\r\n");
    av_opt_set(rtc->whip_uc->priv_data, "headers", headers, 0);
    av_opt_set(rtc->whip_uc->priv_data, "chunked_post", "0", 0);
    av_opt_set_bin(rtc->whip_uc->priv_data, "post_data", rtc->sdp_offer, (int)strlen(rtc->sdp_offer), 0);

    ret = ffurl_connect(rtc->whip_uc, NULL);
    if (ret < 0) {
        av_log(s, AV_LOG_ERROR, "Failed to request url=%s, offer: %s", s->url, rtc->sdp_offer);
        return ret;
    }

    for (;;) {
        ret = ffurl_read(rtc->whip_uc, buf, sizeof(buf));
        if (ret == AVERROR_EOF) {
            /* Reset the error because we read all response as answer util EOF. */
            ret = 0;
            break;
        }
        if (ret <= 0) {
            av_log(s, AV_LOG_ERROR, "Failed to read response from url=%s, offer is %s, answer is %s",
                s->url, rtc->sdp_offer, rtc->sdp_answer);
            return ret;
        }

        p = rtc->sdp_answer;
        rtc->sdp_answer = av_asprintf("%s%.*s", p ? p : "", ret, buf);
        av_free(p);
    }
    av_log(s, AV_LOG_VERBOSE, "Got answer: %s", rtc->sdp_answer);

    return ret;
}

/**
 * Parse the ice ufrag, pwd and candidates from the answer.
 *
 * @return 0 if OK, AVERROR_xxx on error
 */
static int parse_answer(AVFormatContext *s)
{
    int ret = 0;
    AVIOContext *pb;
    char line[MAX_URL_SIZE];
    const char *ptr;
    int i;
    RTCContext *rtc = s->priv_data;

    pb = avio_alloc_context(
        (unsigned char *)rtc->sdp_answer, (int)strlen(rtc->sdp_answer),
        AVIO_FLAG_READ, NULL, NULL, NULL, NULL);
    if (!pb) {
        av_log(s, AV_LOG_ERROR, "Failed to alloc AVIOContext for answer: %s", rtc->sdp_answer);
        ret = AVERROR(ENOMEM);
        goto end;
    }

    for (i = 0; !avio_feof(pb); i++) {
        ff_get_chomp_line(pb, line, sizeof(line));
        if (av_strstart(line, "a=ice-ufrag:", &ptr)) {
            av_freep(&rtc->ice_ufrag_remote);
            rtc->ice_ufrag_remote = av_strdup(ptr);
        } else if (av_strstart(line, "a=ice-pwd:", &ptr)) {
            av_freep(&rtc->ice_pwd_remote);
            rtc->ice_pwd_remote = av_strdup(ptr);
        } else if (av_strstart(line, "a=candidate:", &ptr)) {
            ptr = av_stristr(ptr, "udp");
            if (ptr && av_stristr(ptr, "host")) {
                char protocol[17], host[129];
                int priority, port;
                ret = sscanf(ptr, "%16s %d %128s %d typ host", protocol, &priority, host, &port);
                if (ret != 4) {
                    av_log(s, AV_LOG_ERROR, "Failed %d to parse line %d %s from %s",
                        ret, i, line, rtc->sdp_answer);
                    ret = AVERROR(EINVAL);
                    goto end;
                }

                if (av_strcasecmp(protocol, "udp")) {
                    av_log(s, AV_LOG_ERROR, "Protocol %s is not supported by RTC, choose udp", protocol);
                    ret = AVERROR(EINVAL);
                    goto end;
                }

                av_freep(&rtc->ice_protocol);
                rtc->ice_protocol = av_strdup(protocol);
                av_freep(&rtc->ice_host);
                rtc->ice_host = av_strdup(host);
                rtc->ice_priority = priority;
                rtc->ice_port = port;
            }
        }
    }

end:
    avio_context_free(&pb);
    return ret;
}

static int rtc_init(AVFormatContext *s)
{
    int ret;

    if ((ret = check_codec(s)) < 0)
        return ret;

    if ((ret = generate_sdp_offer(s)) < 0)
        return ret;

    if ((ret = exchange_sdp(s)) < 0)
        return ret;

    if ((ret = parse_answer(s)) < 0)
        return ret;

    return 0;
}

static int rtc_write_header(AVFormatContext *s)
{
    return 0;
}

static int rtc_write_packet(AVFormatContext *s, AVPacket *pkt)
{
    return 0;
}

static int rtc_write_trailer(AVFormatContext *s)
{
    return 0;
}

static void rtc_deinit(AVFormatContext *s)
{
    RTCContext *rtc = s->priv_data;
    av_freep(&rtc->sdp_offer);
    av_freep(&rtc->sdp_answer);
    ffurl_closep(&rtc->whip_uc);
    av_freep(&rtc->ice_ufrag_remote);
    av_freep(&rtc->ice_pwd_remote);
    av_freep(&rtc->ice_protocol);
    av_freep(&rtc->ice_host);
}

static const AVOption options[] = {
    { NULL },
};

static const AVClass rtc_muxer_class = {
    .class_name = "RTC WHIP muxer",
    .item_name  = av_default_item_name,
    .option     = NULL,
    .version    = LIBAVUTIL_VERSION_INT,
};

const FFOutputFormat ff_rtc_muxer = {
    .p.name             = "rtc",
    .p.long_name        = NULL_IF_CONFIG_SMALL("WebRTC WHIP muxer"),
    .p.audio_codec      = AV_CODEC_ID_OPUS,
    .p.video_codec      = AV_CODEC_ID_H264,
    .p.flags            = AVFMT_NOFILE,
    .p.priv_class       = &rtc_muxer_class,
    .priv_data_size     = sizeof(RTCContext),
    .init               = rtc_init,
    .write_header       = rtc_write_header,
    .write_packet       = rtc_write_packet,
    .write_trailer      = rtc_write_trailer,
    .deinit             = rtc_deinit,
};
